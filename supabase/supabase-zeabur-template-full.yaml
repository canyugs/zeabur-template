# yaml-language-server: $schema=https://schema.zeabur.app/template.json
apiVersion: zeabur.com/v1
kind: Template
metadata:
  name: Supabase
spec:
  description: An open source Firebase alternative. We're building the features of Firebase using enterprise-grade open source tools.
  coverImage: https://miro.medium.com/v2/resize:fit:1200/1*KllQKJSGK5QruqT8kIElEA.png
  icon: https://icons.zeabur.com/supabase.png
  variables:
    - key: DASHBOARD_USERNAME
      type: STRING
      name: Dashboard Username
      description: What is the username you want for your Supabase Dashboard?
    - key: PUBLIC_DOMAIN
      type: DOMAIN
      name: Domain
      description: What is the domain you want for your Supabase?
  tags:
      - CMS
      - Database
      - Tool
      - API
  readme: |
    # Supabase for Zeabur Self-hosted
    
    This is a demo of Supabase for Zeabur Self-hosted.
    You can use this template to deploy a Supabase instance on Zeabur.

    ## Services

    This Supabase instance includes **Kong** (API Gateway), **Studio** (Supabase Studio), **PostgreSQL** (Database), **Meta** (Postgres Meta), **REST** (PostgREST), **Auth** (GoTrue), **Supavisor** (Connection Pooler), **Realtime** (Database Change Subscriptions), **Storage** (Storage API), **MinIO** (Object Storage), **ImgProxy** (Image Processing), **Functions** (Edge Functions), **Vector** (Log Aggregation), and **Analytics** (Logflare).

    For detailed architecture information, visit the [official Supabase architecture documentation](https://supabase.com/docs/guides/self-hosting/docker#architecture).

    If you need additional Supabase services, feel free to implement them according to [the upstream `docker-compose.yaml` file](https://github.com/supabase/supabase/blob/master/docker/docker-compose.yml) and submit your changes to [our Discord server](https://zeabur.com/dc). This applies to our [Contribution Reward Program](https://zeabur.com/docs/en-US/billing/reward).

    ## Getting Started

    ### Access the Dashboard

    After deployment, your Supabase Studio dashboard will be available at your configured domain.

    **Finding Your Credentials:**
    1. Go to the **Kong service** in your Zeabur project
    2. Click on the **Instructions** tab
    3. You'll find:
       - **Supabase Username**: Your dashboard username (from `DASHBOARD_USERNAME` variable)
       - **Supabase Password**: Auto-generated secure password

    ### Important Security Keys

    The following keys are exposed in the **Kong service** environment variables:

    | Key | Location | Description |
    |-----|----------|-------------|
    | `JWT_SECRET` | Kong service | Secret for signing JWT tokens |
    | `ANON_KEY` | Kong service | Public API key for anonymous access |
    | `SERVICE_ROLE_KEY` | Kong service | Admin API key with full access |

    **⚠️ CRITICAL**: The default keys are for demo purposes only. You **MUST** generate new keys before production use.

    **How to Generate Secure Keys:**
    1. Visit the [Supabase JWT Generator](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)
    2. Generate new keys using your custom `JWT_SECRET`:
       - Generate `anon` key → use as `ANON_KEY`
       - Generate `service_role` key (shown as `SERVICE_KEY` on the website) → use as `SERVICE_ROLE_KEY`
    3. Update the environment variables in the Kong service
    4. Restart all services to apply changes:
       - Go to your **Project** → **Settings** → **General**
       - Scroll down to **Batch Actions**
       - Click **Restart All** to restart all services

    ## Securing your services
    While we provided you with some example secrets for getting started, you should NEVER deploy your Supabase setup using the defaults we have provided. Follow all of the steps in this section to ensure you have a secure setup, and then restart all services to pick up the changes.

    [Official Guide](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)

    ## Configuration

    ### Add Google OAuth support

    Add the following environment variables to the `auth` service:

    - `GOTRUE_EXTERNAL_GOOGLE_ENABLED=true`
    - `GOTRUE_EXTERNAL_GOOGLE_CLIENT_ID=xxxxxxxx`
    - `GOTRUE_EXTERNAL_GOOGLE_SECRET=yyyyyyyy`
    - `GOTRUE_EXTERNAL_GOOGLE_REDIRECT_URI=https://supabase.zeabur.app/auth/v1/callback`

    Update `supabase.zeabur.app` to your public domain, for example: `supabase.example.com`.

    You can find the client ID and secret in the Google Cloud Console.

    Then, restart your `auth` service.

    ### Add Apple OAuth support

    Add the following environment variables to the `auth` service:

    - `GOTRUE_EXTERNAL_APPLE_ENABLED=true`
    - `GOTRUE_EXTERNAL_APPLE_CLIENT_ID=xxxxxxxx`
    - `GOTRUE_EXTERNAL_APPLE_SECRET=yyyyyyyy`
    - `GOTRUE_EXTERNAL_APPLE_REDIRECT_URI=https://supabase.zeabur.app/auth/v1/callback`

    Update `supabase.zeabur.app` to your public domain, for example: `supabase.example.com`.

    You can find the client ID and secret in the Apple Developer Console.

    Then, restart your `auth` service.

    ### Configure SMTP Email Service (Resend Integration)

    To enable email functionality in Supabase (user verification, password reset, etc.), configure SMTP settings using Resend as the email service provider.

    #### Step 1: Resend Setup (Email Service Provider)

    **Domain Verification:**
    1. Verify your domain (e.g., `mail.yourdomain.com`) in Resend
    2. Configure DNS records (TXT, CNAME, SPF, MX) as provided by Resend
    3. Ensure verification status shows "Verified"

    **Sender Email Setup:**
    1. Configure sender email address: `noreply@mail.yourdomain.com`
    2. Obtain your Resend API key from the dashboard

    #### Step 2: Supabase Auth SMTP Configuration

    Add the following environment variables to the `auth` service:

    - `GOTRUE_SMTP_HOST=smtp.resend.com` - SMTP server host
    - `GOTRUE_SMTP_PORT=587` - Use STARTTLS port
    - `GOTRUE_SMTP_USER=resend` (or leave blank) - Resend doesn't validate username, only API key
    - `GOTRUE_SMTP_PASS=re_xxx` - Your Resend API Key
    - `GOTRUE_SMTP_ADMIN_EMAIL=noreply@mail.yourdomain.com` - Admin sender email
    - `GOTRUE_SMTP_SENDER_NAME=Your App Name` - Display name for emails
    - `GOTRUE_SITE_URL=https://yourdomain.zeabur.app` - Determines the domain for verification links in emails

    #### Step 3: Zeabur Environment Configuration

    1. Navigate to your Zeabur project
    2. Go to Service > Auth > Variables
    3. Add all the SMTP variables listed above
    4. Restart the `auth` service to apply changes

    #### Step 4: Testing Email Functionality

    **Manual Testing:**
    ```bash
    curl -X POST "https://yourdomain.zeabur.app/auth/v1/signup" \
      -H "Content-Type: application/json" \
      -H "apikey: YOUR_ANON_KEY" \
      -d '{
        "email": "test@example.com",
        "password": "yourpassword"
      }'
    ```

    **Expected Results:**
    - Verification email sent successfully
    - Email delivered to recipient (check spam folder initially)
    - Supabase Auth handles registration verification and password reset emails automatically

    #### Troubleshooting Notes

    - **SPF/DKIM Issues:** Ensure all DNS settings match Resend's requirements to prevent email rejection
    - **Redirect URI Mismatch:** Make sure `GOTRUE_SITE_URL` matches your actual deployed domain
    - **Email Delivery:** Initial emails may go to spam; proper DNS configuration improves deliverability
    - **API Key Security:** Store Resend API key securely in environment variables, never in code

    #### Additional Features (Optional)

    For advanced email customization, you can configure:
    - Custom email templates
    - Delivery report webhooks
    - BIMI (Brand Indicators for Message Identification) settings
    - Rate limiting and frequency controls

    ### Advanced Auth Configuration (Optional)

    Add these environment variables to the `auth` service for advanced features:

    **Custom Access Token Hook:**
    - `GOTRUE_HOOK_CUSTOM_ACCESS_TOKEN_ENABLED=true`
    - `GOTRUE_HOOK_CUSTOM_ACCESS_TOKEN_URI=pg-functions://postgres/public/custom_access_token_hook`
    - `GOTRUE_HOOK_CUSTOM_ACCESS_TOKEN_SECRETS=<your-base64-secret>`

    **MFA Verification Hook:**
    - `GOTRUE_HOOK_MFA_VERIFICATION_ATTEMPT_ENABLED=true`
    - `GOTRUE_HOOK_MFA_VERIFICATION_ATTEMPT_URI=pg-functions://postgres/public/mfa_verification_attempt`

    **Password Verification Hook:**
    - `GOTRUE_HOOK_PASSWORD_VERIFICATION_ATTEMPT_ENABLED=true`
    - `GOTRUE_HOOK_PASSWORD_VERIFICATION_ATTEMPT_URI=pg-functions://postgres/public/password_verification_attempt`

    **Custom SMS Hook:**
    - `GOTRUE_HOOK_SEND_SMS_ENABLED=true`
    - `GOTRUE_HOOK_SEND_SMS_URI=pg-functions://postgres/public/custom_sms_hook`
    - `GOTRUE_HOOK_SEND_SMS_SECRETS=v1,whsec_<your-secret>`

    **Custom Email Hook:**
    - `GOTRUE_HOOK_SEND_EMAIL_ENABLED=true`
    - `GOTRUE_HOOK_SEND_EMAIL_URI=http://host.docker.internal:54321/functions/v1/email_sender`
    - `GOTRUE_HOOK_SEND_EMAIL_SECRETS=v1,whsec_<your-secret>`

    **Other Options:**
    - `GOTRUE_EXTERNAL_SKIP_NONCE_CHECK=true` (for mobile Google Sign In)
    - `GOTRUE_MAILER_SECURE_EMAIL_CHANGE_ENABLED=true`
    - `GOTRUE_SMTP_MAX_FREQUENCY=1s`

    **Studio SQL Assistant:**
    Add to `studio` service:
    - `OPENAI_API_KEY=your-openai-api-key`

  services:
    - name: imgproxy
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        ports:
          - id: web
            port: 5001
            type: HTTP
        source:
          image: darthsim/imgproxy:v3.8.0
        volumes:
          - id: vol-0
            dir: /var/lib/storage
        env:
          IMGPROXY_BIND:
            default: ":5001"
          IMGPROXY_LOCAL_FILESYSTEM_ROOT:
            default: /
          IMGPROXY_USE_ETAG:
            default: "true"
          IMGPROXY_ENABLE_WEBP_DETECTION:
            default: "true"
    - name: vector
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        source:
          image: timberio/vector:0.28.1-alpine
        configs:
          - path: /etc/vector/vector.yml
            template: |
              api:
                enabled: true
                address: 0.0.0.0:9001

              sources:
                kubernetes_logs:
                  type: kubernetes_logs
                  self_node_name: ${HOSTNAME}

              transforms:
                project_logs:
                  type: remap
                  inputs:
                    - kubernetes_logs
                  source: |-
                    .project = "default"
                    .event_message = del(.message)
                    .appname = del(.kubernetes.pod_labels."zeabur.com/service-name")
                    del(.container_created_at)
                    del(.container_id)
                    del(.source_type)
                    del(.stream)
                    del(.label)
                    del(.image)
                    del(.host)
                    del(.stream)
                router:
                  type: route
                  inputs:
                    - project_logs
                  route:
                    kong: '.appname == "kong"'
                    auth: '.appname == "auth"'
                    rest: '.appname == "rest"'
                    realtime-dev: '.appname == "realtime-dev"'
                    storage: '.appname == "storage"'
                    functions: '.appname == "functions"'
                    db: '.appname == "postgresql"'
                # Ignores non nginx errors since they are related with kong booting up
                kong_logs:
                  type: remap
                  inputs:
                    - router.kong
                  source: |-
                    req, err = parse_nginx_log(.event_message, "combined")
                    if err == null {
                        .timestamp = req.timestamp
                        .metadata.request.headers.referer = req.referer
                        .metadata.request.headers.user_agent = req.agent
                        .metadata.request.headers.cf_connecting_ip = req.client
                        .metadata.request.method = req.method
                        .metadata.request.path = req.path
                        .metadata.request.protocol = req.protocol
                        .metadata.response.status_code = req.status
                    }
                    if err != null {
                      abort
                    }
                # Ignores non nginx errors since they are related with kong booting up
                kong_err:
                  type: remap
                  inputs:
                    - router.kong
                  source: |-
                    .metadata.request.method = "GET"
                    .metadata.response.status_code = 200
                    parsed, err = parse_nginx_log(.event_message, "error")
                    if err == null {
                        .timestamp = parsed.timestamp
                        .severity = parsed.severity
                        .metadata.request.host = parsed.host
                        .metadata.request.headers.cf_connecting_ip = parsed.client
                        url, err = split(parsed.request, " ")
                        if err == null {
                            .metadata.request.method = url[0]
                            .metadata.request.path = url[1]
                            .metadata.request.protocol = url[2]
                        }
                    }
                    if err != null {
                      abort
                    }
                # Gotrue logs are structured json strings which frontend parses directly. But we keep metadata for consistency.
                auth_logs:
                  type: remap
                  inputs:
                    - router.auth
                  source: |-
                    parsed, err = parse_json(.event_message)
                    if err == null {
                        .metadata.timestamp = parsed.time
                        .metadata = merge!(.metadata, parsed)
                    }
                # PostgREST logs are structured so we separate timestamp from message using regex
                rest_logs:
                  type: remap
                  inputs:
                    - router.rest
                  source: |-
                    parsed, err = parse_regex(.event_message, r'^(?P<time>.*): (?P<msg>.*)$')
                    if err == null {
                        .event_message = parsed.msg
                        .timestamp = to_timestamp!(parsed.time)
                        .metadata.host = .project
                    }
                # Realtime logs are structured so we parse the severity level using regex (ignore time because it has no date)
                realtime_logs:
                  type: remap
                  inputs:
                    - router.realtime-dev
                  source: |-
                    .metadata.project = del(.project)
                    .metadata.external_id = .metadata.project
                    parsed, err = parse_regex(.event_message, r'^(?P<time>\d+:\d+:\d+\.\d+) \[(?P<level>\w+)\] (?P<msg>.*)$')
                    if err == null {
                        .event_message = parsed.msg
                        .metadata.level = parsed.level
                    }
                # Function logs are unstructured messages on stderr
                functions_logs:
                  type: remap
                  inputs:
                    - router.functions
                  source: |-
                    .metadata.project_ref = del(.project)
                # Storage logs may contain json objects so we parse them for completeness
                storage_logs:
                  type: remap
                  inputs:
                    - router.storage
                  source: |-
                    .metadata.project = del(.project)
                    .metadata.tenantId = .metadata.project
                    parsed, err = parse_json(.event_message)
                    if err == null {
                        .event_message = parsed.msg
                        .metadata.level = parsed.level
                        .metadata.timestamp = parsed.time
                        .metadata.context[0].host = parsed.hostname
                        .metadata.context[0].pid = parsed.pid
                    }
                # Postgres logs some messages to stderr which we map to warning severity level
                db_logs:
                  type: remap
                  inputs:
                    - router.db
                  source: |-
                    .metadata.host = "db-default"
                    .metadata.parsed.timestamp = .timestamp

                    parsed, err = parse_regex(.event_message, r'.*(?P<level>INFO|NOTICE|WARNING|ERROR|LOG|FATAL|PANIC?):.*', numeric_groups: true)

                    if err != null || parsed == null {
                      .metadata.parsed.error_severity = "info"
                    }
                    if parsed != null {
                    .metadata.parsed.error_severity = parsed.level
                    }
                    if .metadata.parsed.error_severity == "info" {
                        .metadata.parsed.error_severity = "log"
                    }
                    .metadata.parsed.error_severity = upcase!(.metadata.parsed.error_severity)

              sinks:
                logflare_auth:
                  type: 'http'
                  inputs:
                    - auth_logs
                  encoding:
                    codec: 'json'
                  method: 'post'
                  request:
                    retry_max_duration_secs: 10
                    headers:
                      x-api-key: ${LOGFLARE_PUBLIC_ACCESS_TOKEN?LOGFLARE_PUBLIC_ACCESS_TOKEN is required}
                  uri: 'http://analytics:4000/api/logs?source_name=gotrue.logs.prod'
                logflare_realtime:
                  type: 'http'
                  inputs:
                    - realtime_logs
                  encoding:
                    codec: 'json'
                  method: 'post'
                  request:
                    retry_max_duration_secs: 10
                    headers:
                      x-api-key: ${LOGFLARE_PUBLIC_ACCESS_TOKEN?LOGFLARE_PUBLIC_ACCESS_TOKEN is required}
                  uri: 'http://analytics:4000/api/logs?source_name=realtime.logs.prod'
                logflare_rest:
                  type: 'http'
                  inputs:
                    - rest_logs
                  encoding:
                    codec: 'json'
                  method: 'post'
                  request:
                    retry_max_duration_secs: 10
                    headers:
                      x-api-key: ${LOGFLARE_PUBLIC_ACCESS_TOKEN?LOGFLARE_PUBLIC_ACCESS_TOKEN is required}
                  uri: 'http://analytics:4000/api/logs?source_name=postgREST.logs.prod'
                logflare_db:
                  type: 'http'
                  inputs:
                    - db_logs
                  encoding:
                    codec: 'json'
                  method: 'post'
                  request:
                    retry_max_duration_secs: 10
                    headers:
                      x-api-key: ${LOGFLARE_PUBLIC_ACCESS_TOKEN?LOGFLARE_PUBLIC_ACCESS_TOKEN is required}
                  # We must route the sink through kong because ingesting logs before logflare is fully initialised will
                  # lead to broken queries from studio. This works by the assumption that containers are started in the
                  # following order: vector > db > logflare > kong
                  uri: 'http://kong:8000/analytics/v1/api/logs?source_name=postgres.logs'
                logflare_functions:
                  type: 'http'
                  inputs:
                    - functions_logs
                  encoding:
                    codec: 'json'
                  method: 'post'
                  request:
                    retry_max_duration_secs: 10
                    headers:
                      x-api-key: ${LOGFLARE_PUBLIC_ACCESS_TOKEN?LOGFLARE_PUBLIC_ACCESS_TOKEN is required}
                  uri: 'http://analytics:4000/api/logs?source_name=deno-relay-logs'
                logflare_storage:
                  type: 'http'
                  inputs:
                    - storage_logs
                  encoding:
                    codec: 'json'
                  method: 'post'
                  request:
                    retry_max_duration_secs: 10
                    headers:
                      x-api-key: ${LOGFLARE_PUBLIC_ACCESS_TOKEN?LOGFLARE_PUBLIC_ACCESS_TOKEN is required}
                  uri: 'http://analytics:4000/api/logs?source_name=storage.logs.prod.2'
                logflare_kong:
                  type: 'http'
                  inputs:
                    - kong_logs
                    - kong_err
                  encoding:
                    codec: 'json'
                  method: 'post'
                  request:
                    retry_max_duration_secs: 10
                    headers:
                      x-api-key: ${LOGFLARE_PUBLIC_ACCESS_TOKEN?LOGFLARE_PUBLIC_ACCESS_TOKEN is required}
                  uri: 'http://analytics:4000/api/logs?source_name=cloudflare.logs.prod'
              permission: null
              envsubst: true
        # expose from other services
        # env:
        #   LOGFLARE_PUBLIC_ACCESS_TOKEN:
        #     default: ${LOGFLARE_PUBLIC_ACCESS_TOKEN}

    - name: postgresql
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        source:
          image: supabase/postgres:15.8.1.085
        dependencies:
          - vector
        ports:
          - id: database
            port: 5432
            type: TCP
        volumes:
            - id: data
              dir: /var/lib/postgresql
        instructions:
            - title: Connection String
              content: postgresql://${DATABASE_USER}:${DATABASE_PASSWORD}@${DATABASE_HOST}:${DATABASE_PORT}/${DATABASE_NAME}
            - title: PostgreSQL Connect Command
              content: psql "postgresql://${DATABASE_USER}:${DATABASE_PASSWORD}@${DATABASE_HOST}:${DATABASE_PORT}/${DATABASE_NAME}"
            - title: PostgreSQL username
              content: ${DATABASE_USER}
            - title: PostgresSQL password
              content: ${DATABASE_PASSWORD}
            - title: PostgresSQL database
              content: ${DATABASE_NAME}
            - title: PostgreSQL host
              content: ${DATABASE_HOST}
            - title: PostgreSQL port
              content: ${DATABASE_PORT}
        configs:
          - path: /docker-entrypoint-initdb.d/migrations/99-realtime.sql
            template: |
              \set pguser `echo "$DATABASE_USER"`
              create schema if not exists _realtime;
              alter schema _realtime owner to :pguser;
            permission: null
            envsubst: true
          - path: /docker-entrypoint-initdb.d/init-scripts/98-webhooks.sql
            template: |
              BEGIN;
              -- Create pg_net extension
              CREATE EXTENSION IF NOT EXISTS pg_net SCHEMA extensions;
              -- Create supabase_functions schema
              CREATE SCHEMA supabase_functions AUTHORIZATION supabase_admin;
              GRANT USAGE ON SCHEMA supabase_functions TO postgres, anon, authenticated, service_role;
              ALTER DEFAULT PRIVILEGES IN SCHEMA supabase_functions GRANT ALL ON TABLES TO postgres, anon, authenticated, service_role;
              ALTER DEFAULT PRIVILEGES IN SCHEMA supabase_functions GRANT ALL ON FUNCTIONS TO postgres, anon, authenticated, service_role;
              ALTER DEFAULT PRIVILEGES IN SCHEMA supabase_functions GRANT ALL ON SEQUENCES TO postgres, anon, authenticated, service_role;
              -- supabase_functions.migrations definition
              CREATE TABLE supabase_functions.migrations (
                version text PRIMARY KEY,
                inserted_at timestamptz NOT NULL DEFAULT NOW()
              );
              -- Initial supabase_functions migration
              INSERT INTO supabase_functions.migrations (version) VALUES ('initial');
              -- supabase_functions.hooks definition
              CREATE TABLE supabase_functions.hooks (
                id bigserial PRIMARY KEY,
                hook_table_id integer NOT NULL,
                hook_name text NOT NULL,
                created_at timestamptz NOT NULL DEFAULT NOW(),
                request_id bigint
              );
              CREATE INDEX supabase_functions_hooks_request_id_idx ON supabase_functions.hooks USING btree (request_id);
              CREATE INDEX supabase_functions_hooks_h_table_id_h_name_idx ON supabase_functions.hooks USING btree (hook_table_id, hook_name);
              COMMENT ON TABLE supabase_functions.hooks IS 'Supabase Functions Hooks: Audit trail for triggered hooks.';
              CREATE FUNCTION supabase_functions.http_request()
                RETURNS trigger
                LANGUAGE plpgsql
                AS $function$
                DECLARE
                  request_id bigint;
                  payload jsonb;
                  url text := TG_ARGV[0]::text;
                  method text := TG_ARGV[1]::text;
                  headers jsonb DEFAULT '{}'::jsonb;
                  params jsonb DEFAULT '{}'::jsonb;
                  timeout_ms integer DEFAULT 1000;
                BEGIN
                  IF url IS NULL OR url = 'null' THEN
                    RAISE EXCEPTION 'url argument is missing';
                  END IF;

                  IF method IS NULL OR method = 'null' THEN
                    RAISE EXCEPTION 'method argument is missing';
                  END IF;

                  IF TG_ARGV[2] IS NULL OR TG_ARGV[2] = 'null' THEN
                    headers = '{"Content-Type": "application/json"}'::jsonb;
                  ELSE
                    headers = TG_ARGV[2]::jsonb;
                  END IF;

                  IF TG_ARGV[3] IS NULL OR TG_ARGV[3] = 'null' THEN
                    params = '{}'::jsonb;
                  ELSE
                    params = TG_ARGV[3]::jsonb;
                  END IF;

                  IF TG_ARGV[4] IS NULL OR TG_ARGV[4] = 'null' THEN
                    timeout_ms = 1000;
                  ELSE
                    timeout_ms = TG_ARGV[4]::integer;
                  END IF;

                  CASE
                    WHEN method = 'GET' THEN
                      SELECT http_get INTO request_id FROM net.http_get(
                        url,
                        params,
                        headers,
                        timeout_ms
                      );
                    WHEN method = 'POST' THEN
                      payload = jsonb_build_object(
                        'old_record', OLD,
                        'record', NEW,
                        'type', TG_OP,
                        'table', TG_TABLE_NAME,
                        'schema', TG_TABLE_SCHEMA
                      );

                      SELECT http_post INTO request_id FROM net.http_post(
                        url,
                        payload,
                        params,
                        headers,
                        timeout_ms
                      );
                    ELSE
                      RAISE EXCEPTION 'method argument % is invalid', method;
                  END CASE;

                  INSERT INTO supabase_functions.hooks
                    (hook_table_id, hook_name, request_id)
                  VALUES
                    (TG_RELID, TG_NAME, request_id);

                  RETURN NEW;
                END
              $function$;
              -- Supabase super admin
              DO
              $$
              BEGIN
                IF NOT EXISTS (
                  SELECT 1
                  FROM pg_roles
                  WHERE rolname = 'supabase_functions_admin'
                )
                THEN
                  CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
                END IF;
              END
              $$;
              GRANT ALL PRIVILEGES ON SCHEMA supabase_functions TO supabase_functions_admin;
              GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA supabase_functions TO supabase_functions_admin;
              GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA supabase_functions TO supabase_functions_admin;
              ALTER USER supabase_functions_admin SET search_path = "supabase_functions";
              ALTER table "supabase_functions".migrations OWNER TO supabase_functions_admin;
              ALTER table "supabase_functions".hooks OWNER TO supabase_functions_admin;
              ALTER function "supabase_functions".http_request() OWNER TO supabase_functions_admin;
              GRANT supabase_functions_admin TO postgres;
              -- Remove unused supabase_pg_net_admin role
              DO
              $$
              BEGIN
                IF EXISTS (
                  SELECT 1
                  FROM pg_roles
                  WHERE rolname = 'supabase_pg_net_admin'
                )
                THEN
                  REASSIGN OWNED BY supabase_pg_net_admin TO supabase_admin;
                  DROP OWNED BY supabase_pg_net_admin;
                  DROP ROLE supabase_pg_net_admin;
                END IF;
              END
              $$;
              -- pg_net grants when extension is already enabled
              DO
              $$
              BEGIN
                IF EXISTS (
                  SELECT 1
                  FROM pg_extension
                  WHERE extname = 'pg_net'
                )
                THEN
                  GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;
                  ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
                  ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
                  ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
                  ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
                  REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
                  REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
                  GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
                  GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
                END IF;
              END
              $$;
              -- Event trigger for pg_net
              CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()
              RETURNS event_trigger
              LANGUAGE plpgsql
              AS $$
              BEGIN
                IF EXISTS (
                  SELECT 1
                  FROM pg_event_trigger_ddl_commands() AS ev
                  JOIN pg_extension AS ext
                  ON ev.objid = ext.oid
                  WHERE ext.extname = 'pg_net'
                )
                THEN
                  GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;
                  ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
                  ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
                  ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
                  ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
                  REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
                  REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
                  GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
                  GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
                END IF;
              END;
              $$;
              COMMENT ON FUNCTION extensions.grant_pg_net_access IS 'Grants access to pg_net';
              DO
              $$
              BEGIN
                IF NOT EXISTS (
                  SELECT 1
                  FROM pg_event_trigger
                  WHERE evtname = 'issue_pg_net_access'
                ) THEN
                  CREATE EVENT TRIGGER issue_pg_net_access ON ddl_command_end WHEN TAG IN ('CREATE EXTENSION')
                  EXECUTE PROCEDURE extensions.grant_pg_net_access();
                END IF;
              END
              $$;
              INSERT INTO supabase_functions.migrations (version) VALUES ('20210809183423_update_grants');
              ALTER function supabase_functions.http_request() SECURITY DEFINER;
              ALTER function supabase_functions.http_request() SET search_path = supabase_functions;
              REVOKE ALL ON FUNCTION supabase_functions.http_request() FROM PUBLIC;
              GRANT EXECUTE ON FUNCTION supabase_functions.http_request() TO postgres, anon, authenticated, service_role;
              COMMIT;
            permission: null
            envsubst: null
          - path: /docker-entrypoint-initdb.d/init-scripts/99-roles.sql
            template: |
              -- NOTE: change to your own passwords for production environments
              \set pgpass `echo "$DATABASE_PASSWORD"`
              ALTER USER authenticator WITH PASSWORD :'pgpass';
              ALTER USER pgbouncer WITH PASSWORD :'pgpass';
              ALTER USER supabase_auth_admin WITH PASSWORD :'pgpass';
              ALTER USER supabase_functions_admin WITH PASSWORD :'pgpass';
              ALTER USER supabase_storage_admin WITH PASSWORD :'pgpass';
            permission: null
            envsubst: true
          - path: /docker-entrypoint-initdb.d/init-scripts/99-jwt.sql
            template: |
              \set jwt_secret `echo "$JWT_SECRET"`
              \set jwt_exp `echo "$JWT_EXP"`

              ALTER DATABASE postgres SET "app.settings.jwt_secret" TO :'jwt_secret';
              ALTER DATABASE postgres SET "app.settings.jwt_exp" TO :'jwt_exp';
            permission: null
            envsubst: true
          - path: /docker-entrypoint-initdb.d/migrations/97-_supabase.sql
            template: |
              \set pguser `echo "$DATABASE_USER"`
              CREATE DATABASE _supabase WITH OWNER :pguser;
            permission: null
            envsubst: true
          - path: /docker-entrypoint-initdb.d/migrations/99-logs.sql
            template: |
              \set pguser `echo "$DATABASE_USER"`
              \c _supabase
              create schema if not exists _analytics;
              alter schema _analytics owner to :pguser;
              \c postgres
            permission: null
            envsubst: true
          - path: /docker-entrypoint-initdb.d/migrations/99-pooler.sql
            template: |
              \set pguser `echo "$DATABASE_USER"`
              \c _supabase
              create schema if not exists _supavisor;
              alter schema _supavisor owner to :pguser;
              \c postgres
            permission: null
            envsubst: true
        env:
          # expose from other services
          # JWT_SECRET:
          #   default: your-super-secret-jwt-token-with-at-least-32-characters-long
          #   expose: true
          # JWT_EXPIRY:
          #   default: "3600"
          #   expose: true
          POSTGRES_HOST:
            default: /var/run/postgresql
          POSTGRES_PASSWORD:
            default: ${DATABASE_PASSWORD}
          PGPORT:
            default: ${DATABASE_PORT}
          PGPASSWORD:
            default: ${DATABASE_PASSWORD}
          PGDATABASE:
            default: ${DATABASE_NAME}
          
          DATABASE_NAME:
            default: postgres
            expose: true
          DATABASE_USER:
            default: supabase_admin
            expose: true
          DATABASE_PASSWORD:
            default: ${PASSWORD}
            expose: true
          DATABASE_HOST:
            default: ${CONTAINER_HOSTNAME}
            expose: true
            readonly: true
          DATABASE_PORT:
            default: "5432"
            expose: true
        command:
          - postgres
          - -c
          - config_file=/etc/postgresql/postgresql.conf
          - -c
          - log_min_messages=fatal
    - name: analytics
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        source:
          image: supabase/logflare:1.22.6
        dependencies:
          - postgresql
        ports:
          - id: web
            port: 4000
            type: HTTP
        env:
          LOGFLARE_NODE_HOST:
            default: 127.0.0.1
          DB_USERNAME:
            default: ${DATABASE_USER}
          DB_DATABASE:
            default: _supabase
          DB_HOSTNAME:
            default: postgresql
          DB_PORT:
            default: ${DATABASE_PORT}
          DB_PASSWORD:
            default: ${DATABASE_PASSWORD}
          DB_SCHEMA:
            default: _analytics

          LOGFLARE_PUBLIC_ACCESS_TOKEN:
            default: your-super-secret-and-long-logflare-key-public
            expose: true
          LOGFLARE_PRIVATE_ACCESS_TOKEN:
            default: your-super-secret-and-long-logflare-key-private
            expose: true

          LOGFLARE_SINGLE_TENANT:
            default: "true"
          LOGFLARE_SUPABASE_MODE:
            default: "true"
          LOGFLARE_MIN_CLUSTER_SIZE:
            default: "1"
          POSTGRES_BACKEND_URL:
            default: postgresql://${DATABASE_USER}:${DATABASE_PASSWORD}@${POSTGRESQL_HOST}:${DATABASE_PORT}/_supabase
          POSTGRES_BACKEND_SCHEMA:
            default: _analytics
          LOGFLARE_FEATURE_FLAG_OVERRIDE:
            default: multibackend=true
    - name: meta
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        source:
          image: supabase/postgres-meta:v0.93.1
        ports:
          - id: web
            port: 8080
            type: HTTP
        dependencies:
          - postgresql
        env:
          PG_META_HOST:
            default: 0.0.0.0
          PG_META_PORT:
            default: "8080"
          PG_META_DB_HOST:
            default: postgresql
          PG_META_DB_PORT:
            default: ${DATABASE_PORT}
          PG_META_DB_NAME:
            default: ${DATABASE_NAME}
          PG_META_DB_USER:
            default: ${DATABASE_USER}
          PG_META_DB_PASSWORD:
            default: ${DATABASE_PASSWORD}
          CRYPTO_KEY:
            default: ${PG_META_CRYPTO_KEY}
    - name: auth
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        source:
          image: supabase/gotrue:v2.180.0
        dependencies:
          - postgresql
          - analytics
        ports:
          - id: web
            port: 9999
            type: HTTP
        env:
          GOTRUE_API_HOST:
            default: 0.0.0.0
          GOTRUE_API_PORT:
            default: "9999"
          API_EXTERNAL_URL:
            default: https://${SUPABASE_PUBLIC_DOMAIN}

          GOTRUE_DB_DRIVER:
            default: postgres
          GOTRUE_DB_DATABASE_URL:
            default: postgres://supabase_auth_admin:${DATABASE_PASSWORD}@postgresql:${DATABASE_PORT}/${DATABASE_NAME}

          GOTRUE_SITE_URL:
            default: http://auth:9999
          GOTRUE_URI_ALLOW_LIST:
            default: ""
          GOTRUE_DISABLE_SIGNUP:
            default: "false"
          GOTRUE_JWT_ADMIN_ROLES:
            default: service_role
          GOTRUE_JWT_AUD:
            default: authenticated
          GOTRUE_JWT_DEFAULT_GROUP_NAME:
            default: authenticated
          GOTRUE_JWT_EXP:
            default: ${JWT_EXPIRY}
          GOTRUE_JWT_SECRET:
            default: ${JWT_SECRET}

          # Email configuration
          GOTRUE_EXTERNAL_EMAIL_ENABLED:
            default: "true"
          GOTRUE_EXTERNAL_ANONYMOUS_USERS_ENABLED:
            default: "false"
          GOTRUE_MAILER_AUTOCONFIRM:
            default: "false"
          GOTRUE_SMTP_ADMIN_EMAIL:
            default: admin@example.com
          GOTRUE_SMTP_HOST:
            default: supabase-mail
          GOTRUE_SMTP_PORT:
            default: "2500"
          GOTRUE_SMTP_USER:
            default: fake_mail_user
          GOTRUE_SMTP_PASS:
            default: fake_mail_password
          GOTRUE_SMTP_SENDER_NAME:
            default: fake_sender
          GOTRUE_MAILER_URLPATHS_INVITE:
            default: /auth/v1/verify
          GOTRUE_MAILER_URLPATHS_CONFIRMATION:
            default: /auth/v1/verify
          GOTRUE_MAILER_URLPATHS_RECOVERY:
            default: /auth/v1/verify
          GOTRUE_MAILER_URLPATHS_EMAIL_CHANGE:
            default: /auth/v1/verify

          ## Phone auth
          GOTRUE_EXTERNAL_PHONE_ENABLED:
            default: "true"
          GOTRUE_SMS_AUTOCONFIRM:
            default: "true"
    - name: rest
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        source:
          image: postgrest/postgrest:v13.0.7
        dependencies:
          - postgresql
          - analytics
        ports:
          - id: web
            port: 3000
            type: HTTP
        env:
          PGRST_DB_URI:
            default: postgres://${DATABASE_USER}:${DATABASE_PASSWORD}@${POSTGRESQL_HOST}:${DATABASE_PORT}/${DATABASE_NAME}
          PGRST_DB_SCHEMAS:
            default: public,storage,graphql_public
          PGRST_DB_ANON_ROLE:
            default: anon
          PGRST_JWT_SECRET:
            default: ${JWT_SECRET}
          PGRST_DB_USE_LEGACY_GUCS:
            default: "false"
          PGRST_APP_SETTINGS_JWT_SECRET:
            default: ${JWT_SECRET}
          PGRST_APP_SETTINGS_JWT_EXP:
            default: ${JWT_EXPIRY}
        command:
          - postgrest
    - name: studio
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        source:
          image: supabase/studio:2025.10.27-sha-85b84e0
        dependencies:
          - analytics
          - postgresql
          - kong
        ports:
          - id: web
            port: 3000
            type: HTTP
        env:
          HOSTNAME:
            default: 0.0.0.0
          STUDIO_PG_META_URL:
            default: http://meta:8080
          POSTGRES_DB:
            default: ${DATABASE_NAME}
          POSTGRES_HOST:
            default: postgresql
          POSTGRES_PASSWORD:
            default: ${DATABASE_PASSWORD}
          PG_META_CRYPTO_KEY:
            default: your-encryption-key-32-chars-min
            expose: true
          DEFAULT_ORGANIZATION_NAME:
            default: Default Organization
          DEFAULT_PROJECT_NAME:
            default: Default Project
          OPENAI_API_KEY:
            default: ${OPENAI_API_KEY}
          SUPABASE_URL:
            default: http://kong:8000
          SUPABASE_PUBLIC_URL:
            default: https://${SUPABASE_PUBLIC_DOMAIN}
          SUPABASE_ANON_KEY:
            default: ${ANON_KEY}
          SUPABASE_SERVICE_KEY:
            default: ${SERVICE_ROLE_KEY}
          AUTH_JWT_SECRET:
            default: ${JWT_SECRET}
          # expose from other services
          # LOGFLARE_PRIVATE_ACCESS_TOKEN:
          #   default: ${LOGFLARE_PRIVATE_ACCESS_TOKEN}
          LOGFLARE_URL:
            default: http://analytics:4000
          NEXT_PUBLIC_ENABLE_LOGS:
            default: "true"
          NEXT_ANALYTICS_BACKEND_PROVIDER:
            default: postgres
          NEXT_PUBLIC_IS_PLATFORM:
            default: "false"
          NEXT_PUBLIC_SITE_URL:
            default: http://${SUPABASE_PUBLIC_DOMAIN}
          NEXT_PUBLIC_API_URL:
            default: http://kong:8000/api
    - name: minio
      icon: https://raw.githubusercontent.com/zeabur/service-icons/main/marketplace/minio.svg
      template: PREBUILT
      spec:
        source:
            image: quay.io/minio/minio:latest
            command:
                - /bin/sh
            args:
                - -c
                - |
                  minio server /data --console-address :9090 &
                  MINIO_PID=$!
                  while ! curl -s http://localhost:9000/minio/health/live; do
                    echo 'Waiting for MinIO to start...'
                    sleep 1
                  done
                  sleep 5
                  mc alias set myminio http://localhost:9000 $MINIO_USERNAME $MINIO_PASSWORD
                  echo "Creating bucket '$MINIO_DEFAULT_BUCKET'"
                  mc mb myminio/$MINIO_DEFAULT_BUCKET
                  wait $MINIO_PID
        ports:
            - id: web
              port: 9000
              type: HTTP
            - id: console
              port: 9090
              type: HTTP
        volumes:
            - id: data
              dir: /data
        instructions:
            - title: Go to MinIO Console
              content: ${MINIO_CONSOLE_URL}
            - title: MinIO Username
              content: ${MINIO_USERNAME}
            - title: MinIO Password
              content: ${MINIO_PASSWORD}
        env:
            MINIO_BROWSER_REDIRECT:
                default: "false"
            MINIO_CONSOLE_URL:
                default: ${ZEABUR_CONSOLE_URL}
                expose: true
            MINIO_DEFAULT_BUCKET:
                default: stub
                expose: true
            MINIO_PASSWORD:
                default: ${MINIO_ROOT_PASSWORD}
                expose: true
            MINIO_ROOT_PASSWORD:
                default: ${PASSWORD}
            MINIO_ROOT_USER:
                default: minio
            MINIO_USERNAME:
                default: ${MINIO_ROOT_USER}
                expose: true
    - name: storage
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        source:
          image: supabase/storage-api:v1.28.2
        dependencies:
          - postgresql
          - rest
          - imgproxy
        ports:
          - id: web
            port: 5000
            type: HTTP
        volumes:
          - id: vol-0
            dir: /var/lib/storage
        env:
          POSTGREST_URL:
            default: http://rest:3000
          PGRST_JWT_SECRET:
            default: ${JWT_SECRET}
          PG_STORAGE_ADMIN_USERNAME:
            default: supabase_storage_admin
          PG_STORAGE_ADMIN_PASSWORD:
            default: ${DATABASE_PASSWORD}
          DATABASE_URL:
            default: postgres://${PG_STORAGE_ADMIN_USERNAME}:${PG_STORAGE_ADMIN_PASSWORD}@postgresql:${DATABASE_PORT}/${DATABASE_NAME}
          FILE_SIZE_LIMIT:
            default: "52428800"
          STORAGE_BACKEND:
            default: s3
          FILE_STORAGE_BACKEND_PATH:
            default: /var/lib/storage
          AWS_ACCESS_KEY_ID:
              default: ${MINIO_USERNAME}
          AWS_DEFAULT_REGION:
              default: stub
          AWS_SECRET_ACCESS_KEY:
              default: ${MINIO_PASSWORD}
          GLOBAL_S3_BUCKET:
              default: ${MINIO_DEFAULT_BUCKET}
          GLOBAL_S3_ENDPOINT:
              default: http://minio:9000
          GLOBAL_S3_FORCE_PATH_STYLE:
              default: "true"
          GLOBAL_S3_PROTOCOL:
              default: http
          ENABLE_IMAGE_TRANSFORMATION:
            default: "true"
          IMGPROXY_URL:
            default: http://imgproxy:5001
          TENANT_ID:
            default: stub
          REGION:
            default: stub
    - name: kong
      icon: https://icons.zeabur.com/kong.svg
      template: PREBUILT
      domainKey: PUBLIC_DOMAIN
      spec:
        source:
          image: kong:2.8.1
        dependencies:
          - analytics
        ports:
          - id: web
            port: 8000
            type: HTTP
        instructions:
          - title: Supabase Username
            content: ${DASHBOARD_USERNAME}
          - title: Supabase Password
            content: ${DASHBOARD_PASSWORD}
        configs:
          - path: /home/kong/kong.yml
            template: |
              _format_version: '2.1'
              _transform: true

              ###
              ### Consumers / Users
              ###
              consumers:
                - username: DASHBOARD
                - username: anon
                  keyauth_credentials:
                    - key: ${ANON_KEY}
                - username: service_role
                  keyauth_credentials:
                    - key: ${SERVICE_ROLE_KEY}

              ###
              ### Access Control List
              ###
              acls:
                - consumer: anon
                  group: anon
                - consumer: service_role
                  group: admin

              ###
              ### Dashboard credentials
              ###
              basicauth_credentials:
                - consumer: DASHBOARD
                  username: $DASHBOARD_USERNAME
                  password: $DASHBOARD_PASSWORD

              ###
              ### API Routes
              ###
              services:
                ## Open Auth routes
                - name: auth-v1-open
                  url: http://auth:9999/verify
                  routes:
                    - name: auth-v1-open
                      strip_path: true
                      paths:
                        - /auth/v1/verify
                  plugins:
                    - name: cors
                - name: auth-v1-open-callback
                  url: http://auth:9999/callback
                  routes:
                    - name: auth-v1-open-callback
                      strip_path: true
                      paths:
                        - /auth/v1/callback
                  plugins:
                    - name: cors
                - name: auth-v1-open-authorize
                  url: http://auth:9999/authorize
                  routes:
                    - name: auth-v1-open-authorize
                      strip_path: true
                      paths:
                        - /auth/v1/authorize
                  plugins:
                    - name: cors

                ## Secure Auth routes
                - name: auth-v1
                  _comment: 'GoTrue: /auth/v1/* -> http://auth:9999/*'
                  url: http://auth:9999/
                  routes:
                    - name: auth-v1-all
                      strip_path: true
                      paths:
                        - /auth/v1/
                  plugins:
                    - name: cors
                    - name: key-auth
                      config:
                        hide_credentials: false
                    - name: acl
                      config:
                        hide_groups_header: true
                        allow:
                          - admin
                          - anon

                ## Secure REST routes
                - name: rest-v1
                  _comment: 'PostgREST: /rest/v1/* -> http://rest:3000/*'
                  url: http://rest:3000/
                  routes:
                    - name: rest-v1-all
                      strip_path: true
                      paths:
                        - /rest/v1/
                  plugins:
                    - name: cors
                    - name: key-auth
                      config:
                        hide_credentials: true
                    - name: acl
                      config:
                        hide_groups_header: true
                        allow:
                          - admin
                          - anon

                ## Secure GraphQL routes
                - name: graphql-v1
                  _comment: 'PostgREST: /graphql/v1/* -> http://rest:3000/rpc/graphql'
                  url: http://rest:3000/rpc/graphql
                  routes:
                    - name: graphql-v1-all
                      strip_path: true
                      paths:
                        - /graphql/v1
                  plugins:
                    - name: cors
                    - name: key-auth
                      config:
                        hide_credentials: true
                    - name: request-transformer
                      config:
                        add:
                          headers:
                            - Content-Profile:graphql_public
                    - name: acl
                      config:
                        hide_groups_header: true
                        allow:
                          - admin
                          - anon

                ## Secure Realtime routes
                - name: realtime-v1-ws
                  _comment: 'Realtime: /realtime/v1/* -> ws://realtime-dev:4000/socket/*'
                  url: http://realtime-dev:4000/socket
                  protocol: ws
                  routes:
                    - name: realtime-v1-ws
                      strip_path: true
                      paths:
                        - /realtime/v1/
                  plugins:
                    - name: cors
                    - name: key-auth
                      config:
                        hide_credentials: false
                    - name: acl
                      config:
                        hide_groups_header: true
                        allow:
                          - admin
                          - anon
                - name: realtime-v1-rest
                  _comment: 'Realtime: /realtime/v1/* -> ws://realtime-dev:4000/socket/*'
                  url: http://realtime-dev:4000/api
                  protocol: http
                  routes:
                    - name: realtime-v1-rest
                      strip_path: true
                      paths:
                        - /realtime/v1/api
                  plugins:
                    - name: cors
                    - name: key-auth
                      config:
                        hide_credentials: false
                    - name: acl
                      config:
                        hide_groups_header: true
                        allow:
                          - admin
                          - anon
                ## Storage routes: the storage server manages its own auth
                - name: storage-v1
                  _comment: 'Storage: /storage/v1/* -> http://storage:5000/*'
                  url: http://storage:5000/
                  routes:
                    - name: storage-v1-all
                      strip_path: true
                      paths:
                        - /storage/v1/
                  plugins:
                    - name: cors
          
                ## Edge Functions routes
                - name: functions-v1
                  _comment: 'Edge Functions: /functions/v1/* -> http://functions:9000/*'
                  url: http://functions:9000/
                  routes:
                    - name: functions-v1-all
                      strip_path: true
                      paths:
                        - /functions/v1/
                  plugins:
                    - name: cors

                ## Analytics routes
                - name: analytics-v1
                  _comment: 'Analytics: /analytics/v1/* -> http://logflare:4000/*'
                  url: http://analytics:4000/
                  routes:
                    - name: analytics-v1-all
                      strip_path: true
                      paths:
                        - /analytics/v1/
                ## Secure Database routes
                - name: meta
                  _comment: 'pg-meta: /pg/* -> http://pg-meta:8080/*'
                  url: http://meta:8080/
                  routes:
                    - name: meta-all
                      strip_path: true
                      paths:
                        - /pg/
                  plugins:
                    - name: key-auth
                      config:
                        hide_credentials: false
                    - name: acl
                      config:
                        hide_groups_header: true
                        allow:
                          - admin
                ## Block access to /api/mcp
                - name: mcp-blocker
                  _comment: 'Block direct access to /api/mcp'
                  url: http://studio:3000/api/mcp
                  routes:
                    - name: mcp-blocker-route
                      strip_path: true
                      paths:
                        - /api/mcp
                  plugins:
                    - name: request-termination
                      config:
                        status_code: 403
                        message: "Access is forbidden."

                ## MCP endpoint - local access
                - name: mcp
                  _comment: 'MCP: /mcp -> http://studio:3000/api/mcp (local access)'
                  url: http://studio:3000/api/mcp
                  routes:
                    - name: mcp
                      strip_path: true
                      paths:
                        - /mcp
                  plugins:
                    # Block access to /mcp by default
                    - name: request-termination
                      config:
                        status_code: 403
                        message: "Access is forbidden."
                    # Enable local access (danger zone!)
                    # 1. Comment out the 'request-termination' section above
                    # 2. Uncomment the entire section below, including 'deny'
                    # 3. Add your local IPs to the 'allow' list
                    #- name: cors
                    #- name: ip-restriction
                    #  config:
                    #    allow:
                    #      - 127.0.0.1
                    #      - ::1
                    #    deny: []

                ## Protected Dashboard - catch all remaining routes
                - name: dashboard
                  _comment: 'Studio: /* -> http://studio:3000/*'
                  url: http://studio:3000/
                  routes:
                    - name: dashboard-all
                      strip_path: true
                      paths:
                        - /
                  plugins:
                    - name: cors
                    - name: basic-auth
                      config:
                        hide_credentials: true
            permission: null
            envsubst: true
        env:
          JWT_SECRET:
            default: your-super-secret-jwt-token-with-at-least-32-characters-long
            expose: true
          JWT_EXPIRY:
            default: "3600"
            expose: true
          ANON_KEY:
            default: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyAgCiAgICAicm9sZSI6ICJhbm9uIiwKICAgICJpc3MiOiAic3VwYWJhc2UtZGVtbyIsCiAgICAiaWF0IjogMTY0MTc2OTIwMCwKICAgICJleHAiOiAxNzk5NTM1NjAwCn0.dc_X5iR_VP_qT0zsiyj_I_OZ2T9FtRU2BBNWN8Bu4GE
            expose: true
          SERVICE_ROLE_KEY:
            default: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyAgCiAgICAicm9sZSI6ICJzZXJ2aWNlX3JvbGUiLAogICAgImlzcyI6ICJzdXBhYmFzZS1kZW1vIiwKICAgICJpYXQiOiAxNjQxNzY5MjAwLAogICAgImV4cCI6IDE3OTk1MzU2MDAKfQ.DaYlNEoUrrEn2Ig7tqibS-PHK5vgusbcbo7X36XVt4Q
            expose: true
          DASHBOARD_USERNAME:
            default: ${DASHBOARD_USERNAME}
            expose: true
          DASHBOARD_PASSWORD:
            default: ${PASSWORD}
            expose: true

          KONG_DATABASE:
            default: "off"
          KONG_DECLARATIVE_CONFIG:
            default: /home/kong/kong.yml
          KONG_DNS_ORDER:
            default: LAST,A,CNAME
          KONG_PLUGINS:
            default: request-transformer,cors,key-auth,acl,basic-auth,request-termination,ip-restriction
          KONG_NGINX_WORKER_PROCESSES:
            default: "1"
          KONG_NGINX_PROXY_PROXY_BUFFER_SIZE:
            default: 160k
          KONG_NGINX_PROXY_PROXY_BUFFERS:
            default: 64 160k
          SUPABASE_ANON_KEY:
            default: ${ANON_KEY}
          SUPABASE_SERVICE_KEY:
            default: ${SERVICE_ROLE_KEY}
          SUPABASE_PUBLIC_DOMAIN:
            default: ${ZEABUR_WEB_DOMAIN}
            expose: true
    - name: realtime-dev
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        source:
          image: supabase/realtime:v2.57.2
        dependencies:
          - postgresql
          - analytics
        ports:
          - id: web
            port: 4000
            type: HTTP
        env:
          PORT:
            default: "4000"
          DB_HOST:
            default: postgresql
          DB_PORT:
            default: ${DATABASE_PORT}
          DB_USER:
            default: ${DATABASE_USER}
          DB_PASSWORD:
            default: ${DATABASE_PASSWORD}
          DB_NAME:
            default: ${DATABASE_NAME}
          DB_AFTER_CONNECT_QUERY:
            default: SET search_path TO _realtime
          DB_ENC_KEY:
            default: supabaserealtime
          API_JWT_SECRET:
            default: ${JWT_SECRET}
          # expose from other services
          # SECRET_KEY_BASE:
          #     default: ${PASSWORD}
          ERL_AFLAGS:
            default: -proto_dist inet_tcp
          DNS_NODES:
              default: ''''''
          RLIMIT_NOFILE:
            default: "10000"
          APP_NAME:
            default: realtime-dev
          SEED_SELF_HOST:
            default: "true"
          RUN_JANITOR:
            default: "true"
    - name: supavisor
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        source:
          image: supabase/supavisor:2.7.3
        dependencies:
          - postgresql
        ports:
          - id: web
            port: 4000
            type: HTTP
          - id: port1
            port: 6543
            type: TCP
          - id: port2
            port: 5432
            type: TCP
        configs:
          - path: /etc/pooler/pooler.exs
            template: |
              {:ok, _} = Application.ensure_all_started(:supavisor)

              {:ok, version} =
                case Supavisor.Repo.query!("select version()") do
                  %{rows: [[ver]]} -> Supavisor.Helpers.parse_pg_version(ver)
                  _ -> nil
                end

              params = %{
                "external_id" => System.get_env("POOLER_TENANT_ID"),
                "db_host" => postgresql,
                "db_port" => System.get_env("DATABASE_PORT"),
                "db_database" => System.get_env("DATABASE_NAME"),
                "require_user" => false,
                "auth_query" => "SELECT * FROM pgbouncer.get_auth($1)",
                "default_max_clients" => System.get_env("POOLER_MAX_CLIENT_CONN"),
                "default_pool_size" => System.get_env("POOLER_DEFAULT_POOL_SIZE"),
                "default_parameter_status" => %{"server_version" => version},
                "users" => [%{
                  "db_user" => "pgbouncer",
                  "db_password" => System.get_env("DATABASE_PASSWORD"),
                  "mode_type" => System.get_env("POOLER_POOL_MODE"),
                  "pool_size" => System.get_env("POOLER_DEFAULT_POOL_SIZE"),
                  "is_manager" => true
                }]
              }

              if !Supavisor.Tenants.get_tenant_by_external_id(params["external_id"]) do
                {:ok, _} = Supavisor.Tenants.create_tenant(params)
              end
            permission: null
            envsubst: true
        env:
          PORT:
            default: "4000"
          POSTGRES_PORT:
            default: ${DATABASE_PORT}
          POSTGRES_DB:
            default: ${DATABASE_NAME}
          POSTGRES_PASSWORD:
            default: ${DATABASE_PASSWORD}
          DATABASE_URL:
            default: ecto://supabase_admin:${DATABASE_PASSWORD}@postgresql:${DATABASE_PORT}/_supabase
          CLUSTER_POSTGRES:
            default: "true"
          SECRET_KEY_BASE:
            default: ${PASSWORD}
            expose: true
          VAULT_ENC_KEY:
            default: your-encryption-key-32-chars-min
          API_JWT_SECRET:
            default: ${JWT_SECRET}
          METRICS_JWT_SECRET:
            default: ${JWT_SECRET}
          REGION:
            default: local
          ERL_AFLAGS:
            default: -proto_dist inet_tcp
          POOLER_TENANT_ID:
            default: your-tenant-id
          POOLER_DEFAULT_POOL_SIZE:
            default: "20"
          POOLER_MAX_CLIENT_CONN:
            default: "100"
          POOLER_POOL_MODE:
            default: transaction
          DB_POOL_SIZE:
            default: "20"
        command:
          - /bin/sh
          - -c
          - /app/bin/migrate && /app/bin/supavisor eval "$$(cat /etc/pooler/pooler.exs)" && /app/bin/server
    - name: functions
      icon: https://icons.zeabur.com/supabase.png
      template: PREBUILT
      spec:
        source:
          image: supabase/edge-runtime:v1.69.15
          command:
            - edge-runtime
            - start
            - --main-service
            - /home/deno/functions/main
        dependencies:
          - postgresql    
        ports:
          - id: web
            port: 9000
            type: HTTP
        configs:
          - path: /home/deno/functions/hello/index.ts
            template: |
              // Follow this setup guide to integrate the Deno language server with your editor:
              // https://deno.land/manual/getting_started/setup_your_environment
              // This enables autocomplete, go to definition, etc.

              import { serve } from "https://deno.land/std@0.177.1/http/server.ts"

              serve(async () => {
                return new Response(
                  `"Hello from Edge Functions!"`,
                  { headers: { "Content-Type": "application/json" } },
                )
              })

              // To invoke:
              // curl 'http://localhost:<KONG_HTTP_PORT>/functions/v1/hello' \
              //   --header 'Authorization: Bearer <anon/service_role API key>'
            permission: null
            envsubst: false
          - path: /home/deno/functions/main/index.ts
            template: |
              import { serve } from 'https://deno.land/std@0.131.0/http/server.ts'
              import * as jose from 'https://deno.land/x/jose@v4.14.4/index.ts'

              console.log('main function started')

              const JWT_SECRET = Deno.env.get('JWT_SECRET')
              const VERIFY_JWT = Deno.env.get('VERIFY_JWT') === 'true'

              function getAuthToken(req: Request) {
                const authHeader = req.headers.get('authorization')
                if (!authHeader) {
                  throw new Error('Missing authorization header')
                }
                const [bearer, token] = authHeader.split(' ')
                if (bearer !== 'Bearer') {
                  throw new Error(`Auth header is not 'Bearer {token}'`)
                }
                return token
              }

              async function verifyJWT(jwt: string): Promise<boolean> {
                const encoder = new TextEncoder()
                const secretKey = encoder.encode(JWT_SECRET)
                try {
                  await jose.jwtVerify(jwt, secretKey)
                } catch (err) {
                  console.error(err)
                  return false
                }
                return true
              }

              serve(async (req: Request) => {
                if (req.method !== 'OPTIONS' && VERIFY_JWT) {
                  try {
                    const token = getAuthToken(req)
                    const isValidJWT = await verifyJWT(token)

                    if (!isValidJWT) {
                      return new Response(JSON.stringify({ msg: 'Invalid JWT' }), {
                        status: 401,
                        headers: { 'Content-Type': 'application/json' },
                      })
                    }
                  } catch (e) {
                    console.error(e)
                    return new Response(JSON.stringify({ msg: e.toString() }), {
                      status: 401,
                      headers: { 'Content-Type': 'application/json' },
                    })
                  }
                }

                const url = new URL(req.url)
                const { pathname } = url
                const path_parts = pathname.split('/')
                const service_name = path_parts[1]

                if (!service_name || service_name === '') {
                  const error = { msg: 'missing function name in request' }
                  return new Response(JSON.stringify(error), {
                    status: 400,
                    headers: { 'Content-Type': 'application/json' },
                  })
                }

                const servicePath = `/home/deno/functions/${service_name}`
                console.error(`serving the request with ${servicePath}`)

                const memoryLimitMb = 150
                const workerTimeoutMs = 1 * 60 * 1000
                const noModuleCache = false
                const importMapPath = null
                const envVarsObj = Deno.env.toObject()
                const envVars = Object.keys(envVarsObj).map((k) => [k, envVarsObj[k]])

                try {
                  const worker = await EdgeRuntime.userWorkers.create({
                    servicePath,
                    memoryLimitMb,
                    workerTimeoutMs,
                    noModuleCache,
                    importMapPath,
                    envVars,
                  })
                  return await worker.fetch(req)
                } catch (e) {
                  const error = { msg: e.toString() }
                  return new Response(JSON.stringify(error), {
                    status: 500,
                    headers: { 'Content-Type': 'application/json' },
                  })
                }
              })
            permission: null
            envsubst: false
        volumes:
          - id: vol-0
            dir: /home/deno/functions
        env:
          # expose from other services
          # JWT_SECRET:
          #   default: ${JWT_SECRET}
          SUPABASE_URL:
            default: http://kong:8000
          SUPABASE_ANON_KEY:
            default: ${ANON_KEY}
          SUPABASE_SERVICE_ROLE_KEY:
            default: ${SERVICE_ROLE_KEY}
          SUPABASE_DB_URL:
            default: postgresql://${DATABASE_USER}:${DATABASE_PASSWORD}@postgresql:${DATABASE_PORT}/${DATABASE_NAME}
          # TODO: Allow configuring VERIFY_JWT per function. This PR might help: https://github.com/supabase/cli/pull/786
          VERIFY_JWT:
            default: "false"

localization:
  zh-TW:
    description: 開源的 Firebase 替代方案。我們使用企業級開源工具來建構 Firebase 的功能。
    variables:
      - key: DASHBOARD_USERNAME
        type: STRING
        name: 儀表板使用者名稱
        description: 你想為 Supabase 儀表板設定什麼使用者名稱？
      - key: PUBLIC_DOMAIN
        type: DOMAIN
        name: 網域
        description: 你想為 Supabase 使用什麼網域？
    readme: |
      # Supabase Zeabur 自架版

      這是 Supabase 在 Zeabur 上的自架版範例。
      你可以使用這個模板在 Zeabur 上部署 Supabase 實例。

      ## 服務

      此 Supabase 實例包含 **Kong**（API 閘道）、**Studio**（Supabase Studio）、**PostgreSQL**（資料庫）、**Meta**（Postgres Meta）、**REST**（PostgREST）、**Auth**（GoTrue）、**Supavisor**（連線池）、**Realtime**（資料庫變更訂閱）、**Storage**（儲存 API）、**MinIO**（物件儲存）、**ImgProxy**（圖片處理）、**Functions**（Edge Functions）、**Vector**（日誌聚合）和 **Analytics**（Logflare）。

      詳細架構資訊請參考[官方 Supabase 架構文件](https://supabase.com/docs/guides/self-hosting/docker#architecture)。

      如果你需要額外的 Supabase 服務，歡迎根據[上游 `docker-compose.yaml` 檔案](https://github.com/supabase/supabase/blob/master/docker/docker-compose.yml)實作，並將你的變更提交到[我們的 Discord 伺服器](https://zeabur.com/dc)。這適用於我們的[貢獻獎勵計畫](https://zeabur.com/docs/zh-TW/billing/reward)。

      ## 開始使用

      ### 訪問儀表板

      部署完成後，你的 Supabase Studio 儀表板將可在你配置的網域上使用。

      **查詢登入憑證：**
      1. 前往 Zeabur 專案中的 **Kong 服務**
      2. 點擊 **Instructions（說明）** 標籤
      3. 你會看到：
         - **Supabase Username**：你的儀表板使用者名稱（來自 `DASHBOARD_USERNAME` 變數）
         - **Supabase Password**：自動生成的安全密碼

      ### 重要安全密鑰

      以下密鑰在 **Kong 服務** 的環境變數中公開：

      | 密鑰 | 位置 | 說明 |
      |-----|----------|-------------|
      | `JWT_SECRET` | Kong 服務 | 用於簽署 JWT 令牌的密鑰 |
      | `ANON_KEY` | Kong 服務 | 匿名訪問的公開 API 密鑰 |
      | `SERVICE_ROLE_KEY` | Kong 服務 | 具有完整訪問權限的管理員 API 密鑰 |

      **⚠️ 重要**：預設密鑰僅供示範使用。在正式環境使用前，你**必須**生成新的密鑰。

      **如何生成安全密鑰：**
      1. 訪問 [Supabase JWT 生成器](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)
      2. 使用你的自訂 `JWT_SECRET` 生成新的密鑰：
         - 生成 `anon` 密鑰 → 作為 `ANON_KEY` 使用
         - 生成 `service_role` 密鑰（網站上顯示為 `SERVICE_KEY`）→ 作為 `SERVICE_ROLE_KEY` 使用
      3. 在 Kong 服務中更新環境變數
      4. 重啟所有服務以套用變更：
         - 進入你的 **專案** → **設定** → **一般設定**
         - 向下捲動到 **批次動作**
         - 點擊 **全部重啟** 以重啟所有服務

      ## 保護你的服務

      雖然我們提供了一些範例密鑰以便快速開始，但你絕對不應該使用我們提供的預設值來部署 Supabase。請依照本節中的所有步驟確保你有安全的設定，然後重啟所有服務以套用變更。

      [官方指南](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)

      ## 配置

      ### 新增 Google OAuth 支援

      在 `auth` 服務中新增以下環境變數：

      - `GOTRUE_EXTERNAL_GOOGLE_ENABLED=true`
      - `GOTRUE_EXTERNAL_GOOGLE_CLIENT_ID=xxxxxxxx`
      - `GOTRUE_EXTERNAL_GOOGLE_SECRET=yyyyyyyy`
      - `GOTRUE_EXTERNAL_GOOGLE_REDIRECT_URI=https://supabase.zeabur.app/auth/v1/callback`

      將 `supabase.zeabur.app` 更新為你的公開網域，例如：`supabase.example.com`。

      你可以在 Google Cloud Console 中找到客戶端 ID 和密鑰。

      然後，重啟你的 `auth` 服務。

      ### 新增 Apple OAuth 支援

      在 `auth` 服務中新增以下環境變數：

      - `GOTRUE_EXTERNAL_APPLE_ENABLED=true`
      - `GOTRUE_EXTERNAL_APPLE_CLIENT_ID=xxxxxxxx`
      - `GOTRUE_EXTERNAL_APPLE_SECRET=yyyyyyyy`
      - `GOTRUE_EXTERNAL_APPLE_REDIRECT_URI=https://supabase.zeabur.app/auth/v1/callback`

      將 `supabase.zeabur.app` 更新為你的公開網域，例如：`supabase.example.com`。

      你可以在 Apple Developer Console 中找到客戶端 ID 和密鑰。

      然後，重啟你的 `auth` 服務。

      ### 配置 SMTP 電子郵件服務（Resend 整合）

      要在 Supabase 中啟用電子郵件功能（使用者驗證、密碼重設等），請使用 Resend 作為電子郵件服務提供商配置 SMTP 設定。

      #### 步驟 1：Resend 設定（電子郵件服務提供商）

      **網域驗證：**
      1. 在 Resend 中驗證你的網域（例如：`mail.yourdomain.com`）
      2. 依照 Resend 提供的設定 DNS 記錄（TXT、CNAME、SPF、MX）
      3. 確保驗證狀態顯示「已驗證」

      **寄件者電子郵件設定：**
      1. 配置寄件者電子郵件地址：`noreply@mail.yourdomain.com`
      2. 從儀表板取得你的 Resend API 金鑰

      #### 步驟 2：Supabase Auth SMTP 配置

      在 `auth` 服務中新增以下環境變數：

      - `GOTRUE_SMTP_HOST=smtp.resend.com` - SMTP 伺服器主機
      - `GOTRUE_SMTP_PORT=587` - 使用 STARTTLS 埠號
      - `GOTRUE_SMTP_USER=resend`（或留空）- Resend 不驗證使用者名稱，只驗證 API 金鑰
      - `GOTRUE_SMTP_PASS=re_xxx` - 你的 Resend API 金鑰
      - `GOTRUE_SMTP_ADMIN_EMAIL=noreply@mail.yourdomain.com` - 管理員寄件者電子郵件
      - `GOTRUE_SMTP_SENDER_NAME=Your App Name` - 電子郵件的顯示名稱
      - `GOTRUE_SITE_URL=https://yourdomain.zeabur.app` - 決定電子郵件中驗證連結的網域

      #### 步驟 3：Zeabur 環境配置

      1. 前往你的 Zeabur 專案
      2. 前往 Service > Auth > Variables
      3. 新增上述所有 SMTP 變數
      4. 重啟 `auth` 服務以套用變更

      #### 步驟 4：測試電子郵件功能

      **手動測試：**
      ```bash
      curl -X POST "https://yourdomain.zeabur.app/auth/v1/signup" \
        -H "Content-Type: application/json" \
        -H "apikey: YOUR_ANON_KEY" \
        -d '{
          "email": "test@example.com",
          "password": "yourpassword"
        }'
      ```

      **預期結果：**
      - 驗證電子郵件成功傳送
      - 電子郵件送達收件者（最初請檢查垃圾郵件資料夾）
      - Supabase Auth 自動處理註冊驗證和密碼重設電子郵件

      #### 疑難排解注意事項

      - **SPF/DKIM 問題：** 確保所有 DNS 設定符合 Resend 的要求，以防止電子郵件被拒絕
      - **重新導向 URI 不符：** 確保 `GOTRUE_SITE_URL` 符合你實際部署的網域
      - **電子郵件送達：** 初始電子郵件可能會進入垃圾郵件；適當的 DNS 配置可提高送達率
      - **API 金鑰安全性：** 將 Resend API 金鑰安全地儲存在環境變數中，切勿在程式碼中

      #### 其他功能（可選）

      對於進階電子郵件自訂，你可以配置：
      - 自訂電子郵件範本
      - 傳遞報告 webhook
      - BIMI（訊息識別品牌指標）設定
      - 速率限制和頻率控制

      ### 進階 Auth 配置（可選）

      在 `auth` 服務中新增這些環境變數以啟用進階功能：

      **自訂存取令牌掛鉤：**
      - `GOTRUE_HOOK_CUSTOM_ACCESS_TOKEN_ENABLED=true`
      - `GOTRUE_HOOK_CUSTOM_ACCESS_TOKEN_URI=pg-functions://postgres/public/custom_access_token_hook`
      - `GOTRUE_HOOK_CUSTOM_ACCESS_TOKEN_SECRETS=<your-base64-secret>`

      **MFA 驗證掛鉤：**
      - `GOTRUE_HOOK_MFA_VERIFICATION_ATTEMPT_ENABLED=true`
      - `GOTRUE_HOOK_MFA_VERIFICATION_ATTEMPT_URI=pg-functions://postgres/public/mfa_verification_attempt`

      **密碼驗證掛鉤：**
      - `GOTRUE_HOOK_PASSWORD_VERIFICATION_ATTEMPT_ENABLED=true`
      - `GOTRUE_HOOK_PASSWORD_VERIFICATION_ATTEMPT_URI=pg-functions://postgres/public/password_verification_attempt`

      **自訂 SMS 掛鉤：**
      - `GOTRUE_HOOK_SEND_SMS_ENABLED=true`
      - `GOTRUE_HOOK_SEND_SMS_URI=pg-functions://postgres/public/custom_sms_hook`
      - `GOTRUE_HOOK_SEND_SMS_SECRETS=v1,whsec_<your-secret>`

      **自訂電子郵件掛鉤：**
      - `GOTRUE_HOOK_SEND_EMAIL_ENABLED=true`
      - `GOTRUE_HOOK_SEND_EMAIL_URI=http://host.docker.internal:54321/functions/v1/email_sender`
      - `GOTRUE_HOOK_SEND_EMAIL_SECRETS=v1,whsec_<your-secret>`

      **其他選項：**
      - `GOTRUE_EXTERNAL_SKIP_NONCE_CHECK=true`（用於行動裝置 Google 登入）
      - `GOTRUE_MAILER_SECURE_EMAIL_CHANGE_ENABLED=true`
      - `GOTRUE_SMTP_MAX_FREQUENCY=1s`

      **Studio SQL 助手：**
      新增至 `studio` 服務：
      - `OPENAI_API_KEY=your-openai-api-key`

  zh-CN:
    description: 开源的 Firebase 替代方案。我们使用企业级开源工具来构建 Firebase 的功能。
    variables:
      - key: DASHBOARD_USERNAME
        type: STRING
        name: 仪表板用户名
        description: 你想为 Supabase 仪表板设置什么用户名？
      - key: PUBLIC_DOMAIN
        type: DOMAIN
        name: 域名
        description: 你想为 Supabase 使用什么域名？
    readme: |
      # Supabase Zeabur 自托管版

      这是 Supabase 在 Zeabur 上的自托管版示例。
      你可以使用这个模板在 Zeabur 上部署 Supabase 实例。

      ## 服务

      此 Supabase 实例包含 **Kong**（API 网关）、**Studio**（Supabase Studio）、**PostgreSQL**（数据库）、**Meta**（Postgres Meta）、**REST**（PostgREST）、**Auth**（GoTrue）、**Supavisor**（连接池）、**Realtime**（数据库变更订阅）、**Storage**（存储 API）、**MinIO**（对象存储）、**ImgProxy**（图片处理）、**Functions**（Edge Functions）、**Vector**（日志聚合）和 **Analytics**（Logflare）。

      详细架构信息请参考[官方 Supabase 架构文档](https://supabase.com/docs/guides/self-hosting/docker#architecture)。

      如果你需要额外的 Supabase 服务，欢迎根据[上游 `docker-compose.yaml` 文件](https://github.com/supabase/supabase/blob/master/docker/docker-compose.yml)实现，并将你的更改提交到[我们的 Discord 服务器](https://zeabur.com/dc)。这适用于我们的[贡献奖励计划](https://zeabur.com/docs/zh-CN/billing/reward)。

      ## 开始使用

      ### 访问仪表板

      部署完成后，你的 Supabase Studio 仪表板将可在你配置的域名上使用。

      **查询登录凭证：**
      1. 前往 Zeabur 项目中的 **Kong 服务**
      2. 点击 **Instructions（说明）** 标签
      3. 你会看到：
         - **Supabase Username**：你的仪表板用户名（来自 `DASHBOARD_USERNAME` 变量）
         - **Supabase Password**：自动生成的安全密码

      ### 重要安全密钥

      以下密钥在 **Kong 服务** 的环境变量中公开：

      | 密钥 | 位置 | 说明 |
      |-----|----------|-------------|
      | `JWT_SECRET` | Kong 服务 | 用于签署 JWT 令牌的密钥 |
      | `ANON_KEY` | Kong 服务 | 匿名访问的公开 API 密钥 |
      | `SERVICE_ROLE_KEY` | Kong 服务 | 具有完整访问权限的管理员 API 密钥 |

      **⚠️ 重要**：默认密钥仅供演示使用。在正式环境使用前，你**必须**生成新的密钥。

      **如何生成安全密钥：**
      1. 访问 [Supabase JWT 生成器](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)
      2. 使用你的自定义 `JWT_SECRET` 生成新的密钥：
         - 生成 `anon` 密钥 → 作为 `ANON_KEY` 使用
         - 生成 `service_role` 密钥（网站上显示为 `SERVICE_KEY`）→ 作为 `SERVICE_ROLE_KEY` 使用
      3. 在 Kong 服务中更新环境变量
      4. 重启所有服务以应用更改：
         - 进入你的 **项目** → **设置** → **常规设置**
         - 向下滚动到 **批量操作**
         - 点击 **全部重启** 以重启所有服务

      ## 保护你的服务

      虽然我们提供了一些示例密钥以便快速开始，但你绝对不应该使用我们提供的默认值来部署 Supabase。请依照本节中的所有步骤确保你有安全的设置，然后重启所有服务以应用更改。

      [官方指南](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)

      ## 配置

      ### 添加 Google OAuth 支持

      在 `auth` 服务中添加以下环境变量：`GOTRUE_EXTERNAL_GOOGLE_ENABLED=true`、`GOTRUE_EXTERNAL_GOOGLE_CLIENT_ID`、`GOTRUE_EXTERNAL_GOOGLE_SECRET`、`GOTRUE_EXTERNAL_GOOGLE_REDIRECT_URI`。将域名更新为你的公开域名。

      ### 添加 Apple OAuth 支持

      在 `auth` 服务中添加以下环境变量：`GOTRUE_EXTERNAL_APPLE_ENABLED=true`、`GOTRUE_EXTERNAL_APPLE_CLIENT_ID`、`GOTRUE_EXTERNAL_APPLE_SECRET`、`GOTRUE_EXTERNAL_APPLE_REDIRECT_URI`。

      ### 配置 SMTP 邮件服务（Resend 集成）

      要启用邮件功能（用户验证、密码重置等），使用 Resend 配置 SMTP 设置：

      **Resend 设置：**
      1. 在 Resend 中验证你的域名（如 `mail.yourdomain.com`）
      2. 配置 DNS 记录（TXT、CNAME、SPF、MX）
      3. 获取 Resend API 密钥

      **Auth 服务 SMTP 配置：**
      在 `auth` 服务中添加：`GOTRUE_SMTP_HOST=smtp.resend.com`、`GOTRUE_SMTP_PORT=587`、`GOTRUE_SMTP_PASS=re_xxx`（你的 Resend API 密钥）、`GOTRUE_SMTP_ADMIN_EMAIL`、`GOTRUE_SMTP_SENDER_NAME`、`GOTRUE_SITE_URL`。

      ### 高级 Auth 配置（可选）

      支持自定义访问令牌钩子、MFA 验证钩子、密码验证钩子、自定义 SMS/Email 钩子等。在 `auth` 服务中添加相应的 `GOTRUE_HOOK_*` 环境变量。

      **Studio SQL 助手：**
      在 `studio` 服务中添加：`OPENAI_API_KEY=your-openai-api-key`

  ja-JP:
    description: オープンソースの Firebase 代替。エンタープライズグレードのオープンソースツールを使用して Firebase の機能を構築しています。
    variables:
      - key: DASHBOARD_USERNAME
        type: STRING
        name: ダッシュボードユーザー名
        description: Supabase ダッシュボードに使用するユーザー名は何ですか？
      - key: PUBLIC_DOMAIN
        type: DOMAIN
        name: ドメイン
        description: Supabase に使用するドメインは何ですか？
    readme: |
      # Supabase Zeabur セルフホスティング版

      これは Zeabur 上での Supabase セルフホスティング版のデモです。
      このテンプレートを使用して Zeabur 上に Supabase インスタンスをデプロイできます。

      ## サービス

      この Supabase インスタンスには、**Kong**（API ゲートウェイ）、**Studio**（Supabase Studio）、**PostgreSQL**（データベース）、**Meta**（Postgres Meta）、**REST**（PostgREST）、**Auth**（GoTrue）、**Supavisor**（コネクションプーラー）、**Realtime**（データベース変更サブスクリプション）、**Storage**（ストレージ API）、**MinIO**（オブジェクトストレージ）、**ImgProxy**（画像処理）、**Functions**（Edge Functions）、**Vector**（ログ集約）、**Analytics**（Logflare）が含まれています。

      詳細なアーキテクチャ情報については、[公式 Supabase アーキテクチャドキュメント](https://supabase.com/docs/guides/self-hosting/docker#architecture)をご覧ください。

      追加の Supabase サービスが必要な場合は、[上流の `docker-compose.yaml` ファイル](https://github.com/supabase/supabase/blob/master/docker/docker-compose.yml)に従って実装し、[Discord サーバー](https://zeabur.com/dc)に変更を提出してください。これは[貢献報酬プログラム](https://zeabur.com/docs/ja-JP/billing/reward)の対象となります。

      ## はじめに

      ### ダッシュボードへのアクセス

      デプロイ後、設定したドメインで Supabase Studio ダッシュボードが利用可能になります。

      **認証情報の確認：**
      1. Zeabur プロジェクトの **Kong サービス** に移動
      2. **Instructions（手順）** タブをクリック
      3. 以下が表示されます：
         - **Supabase Username**：ダッシュボードのユーザー名（`DASHBOARD_USERNAME` 変数から）
         - **Supabase Password**：自動生成された安全なパスワード

      ### 重要なセキュリティキー

      以下のキーは **Kong サービス** の環境変数で公開されています：

      | キー | 場所 | 説明 |
      |-----|----------|-------------|
      | `JWT_SECRET` | Kong サービス | JWT トークンの署名用シークレット |
      | `ANON_KEY` | Kong サービス | 匿名アクセス用のパブリック API キー |
      | `SERVICE_ROLE_KEY` | Kong サービス | フルアクセス権限を持つ管理者 API キー |

      **⚠️ 重要**：デフォルトのキーはデモ用です。本番環境で使用する前に、新しいキーを生成**する必要があります**。

      **安全なキーの生成方法：**
      1. [Supabase JWT ジェネレーター](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)にアクセス
      2. カスタムの `JWT_SECRET` を使用して新しいキーを生成：
         - `anon` キーを生成 → `ANON_KEY` として使用
         - `service_role` キーを生成（Web サイトでは `SERVICE_KEY` と表示）→ `SERVICE_ROLE_KEY` として使用
      3. Kong サービスで環境変数を更新
      4. すべてのサービスを再起動して変更を適用：
         - **プロジェクト** → **設定** → **一般** に移動
         - **バッチアクション** までスクロール
         - **すべて再起動** をクリックしてすべてのサービスを再起動

      ## サービスの保護

      開始するためにいくつかのサンプルシークレットを提供していますが、提供されているデフォルトを使用して Supabase セットアップをデプロイしてはいけません。このセクションのすべての手順に従って安全なセットアップを確保し、すべてのサービスを再起動して変更を適用してください。

      [公式ガイド](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)

      ## 設定

      ### Google OAuth サポートの追加

      `auth` サービスに環境変数を追加：`GOTRUE_EXTERNAL_GOOGLE_ENABLED=true`、`GOTRUE_EXTERNAL_GOOGLE_CLIENT_ID`、`GOTRUE_EXTERNAL_GOOGLE_SECRET`、`GOTRUE_EXTERNAL_GOOGLE_REDIRECT_URI`。

      ### Apple OAuth サポートの追加

      `auth` サービスに環境変数を追加：`GOTRUE_EXTERNAL_APPLE_ENABLED=true`、`GOTRUE_EXTERNAL_APPLE_CLIENT_ID`、`GOTRUE_EXTERNAL_APPLE_SECRET`、`GOTRUE_EXTERNAL_APPLE_REDIRECT_URI`。

      ### SMTP メールサービスの設定（Resend 統合）

      メール機能を有効にするには、Resend を使用して SMTP 設定を構成します。`auth` サービスに `GOTRUE_SMTP_HOST=smtp.resend.com`、`GOTRUE_SMTP_PORT=587`、`GOTRUE_SMTP_PASS`（Resend API キー）、`GOTRUE_SMTP_ADMIN_EMAIL`、`GOTRUE_SMTP_SENDER_NAME`、`GOTRUE_SITE_URL` を追加します。

      ### 高度な Auth 設定（オプション）

      カスタムアクセストークンフック、MFA 検証フック、パスワード検証フック、カスタム SMS/Email フックなどをサポート。`auth` サービスに対応する `GOTRUE_HOOK_*` 環境変数を追加します。

      **Studio SQL アシスタント：**
      `studio` サービスに `OPENAI_API_KEY` を追加。

  es-ES:
    description: Una alternativa de código abierto a Firebase. Estamos construyendo las características de Firebase utilizando herramientas de código abierto de nivel empresarial.
    variables:
      - key: DASHBOARD_USERNAME
        type: STRING
        name: Nombre de usuario del panel
        description: ¿Qué nombre de usuario deseas para tu panel de Supabase?
      - key: PUBLIC_DOMAIN
        type: DOMAIN
        name: Dominio
        description: ¿Qué dominio deseas para tu Supabase?
    readme: |
      # Supabase Auto-alojado en Zeabur

      Esta es una demostración de Supabase auto-alojado en Zeabur.
      Puedes usar esta plantilla para desplegar una instancia de Supabase en Zeabur.

      ## Servicios

      Esta instancia de Supabase incluye **Kong** (Gateway API), **Studio** (Supabase Studio), **PostgreSQL** (Base de Datos), **Meta** (Postgres Meta), **REST** (PostgREST), **Auth** (GoTrue), **Supavisor** (Pool de Conexiones), **Realtime** (Suscripciones a Cambios de Base de Datos), **Storage** (API de Almacenamiento), **MinIO** (Almacenamiento de Objetos), **ImgProxy** (Procesamiento de Imágenes), **Functions** (Edge Functions), **Vector** (Agregación de Registros) y **Analytics** (Logflare).

      Para información detallada sobre la arquitectura, visita la [documentación oficial de arquitectura de Supabase](https://supabase.com/docs/guides/self-hosting/docker#architecture).

      Si necesitas servicios adicionales de Supabase, siéntete libre de implementarlos según el [archivo `docker-compose.yaml` upstream](https://github.com/supabase/supabase/blob/master/docker/docker-compose.yml) y enviar tus cambios a [nuestro servidor de Discord](https://zeabur.com/dc). Esto aplica a nuestro [Programa de Recompensas por Contribución](https://zeabur.com/docs/es-ES/billing/reward).

      ## Comenzar

      ### Acceder al Panel

      Después del despliegue, tu panel de Supabase Studio estará disponible en tu dominio configurado.

      **Encontrar tus Credenciales:**
      1. Ve al **servicio Kong** en tu proyecto Zeabur
      2. Haz clic en la pestaña **Instructions (Instrucciones)**
      3. Encontrarás:
         - **Supabase Username**: Tu nombre de usuario del panel (de la variable `DASHBOARD_USERNAME`)
         - **Supabase Password**: Contraseña segura generada automáticamente

      ### Claves de Seguridad Importantes

      Las siguientes claves están expuestas en las variables de entorno del **servicio Kong**:

      | Clave | Ubicación | Descripción |
      |-----|----------|-------------|
      | `JWT_SECRET` | Servicio Kong | Secreto para firmar tokens JWT |
      | `ANON_KEY` | Servicio Kong | Clave API pública para acceso anónimo |
      | `SERVICE_ROLE_KEY` | Servicio Kong | Clave API de administrador con acceso completo |

      **⚠️ CRÍTICO**: Las claves predeterminadas son solo para fines de demostración. **DEBES** generar nuevas claves antes del uso en producción.

      **Cómo Generar Claves Seguras:**
      1. Visita el [Generador JWT de Supabase](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)
      2. Genera nuevas claves usando tu `JWT_SECRET` personalizado:
         - Genera clave `anon` → úsala como `ANON_KEY`
         - Genera clave `service_role` (mostrada como `SERVICE_KEY` en el sitio web) → úsala como `SERVICE_ROLE_KEY`
      3. Actualiza las variables de entorno en el servicio Kong
      4. Reinicia todos los servicios para aplicar los cambios:
         - Ve a tu **Proyecto** → **Configuración** → **General**
         - Desplázate hacia abajo hasta **Acciones por Lotes**
         - Haz clic en **Reiniciar Todo** para reiniciar todos los servicios

      ## Asegurar tus Servicios

      Aunque proporcionamos algunos secretos de ejemplo para comenzar, NUNCA debes desplegar tu configuración de Supabase usando los valores predeterminados que hemos proporcionado. Sigue todos los pasos en esta sección para asegurar que tienes una configuración segura, y luego reinicia todos los servicios para aplicar los cambios.

      [Guía Oficial](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)

      ## Configuración

      ### Agregar soporte de Google OAuth

      Agrega variables de entorno al servicio `auth`: `GOTRUE_EXTERNAL_GOOGLE_ENABLED=true`, `GOTRUE_EXTERNAL_GOOGLE_CLIENT_ID`, `GOTRUE_EXTERNAL_GOOGLE_SECRET`, `GOTRUE_EXTERNAL_GOOGLE_REDIRECT_URI`.

      ### Agregar soporte de Apple OAuth

      Agrega variables de entorno al servicio `auth`: `GOTRUE_EXTERNAL_APPLE_ENABLED=true`, `GOTRUE_EXTERNAL_APPLE_CLIENT_ID`, `GOTRUE_EXTERNAL_APPLE_SECRET`, `GOTRUE_EXTERNAL_APPLE_REDIRECT_URI`.

      ### Configurar servicio de correo SMTP (Integración con Resend)

      Para habilitar la funcionalidad de correo, configura SMTP usando Resend. Agrega al servicio `auth`: `GOTRUE_SMTP_HOST=smtp.resend.com`, `GOTRUE_SMTP_PORT=587`, `GOTRUE_SMTP_PASS` (tu clave API de Resend), `GOTRUE_SMTP_ADMIN_EMAIL`, `GOTRUE_SMTP_SENDER_NAME`, `GOTRUE_SITE_URL`.

      ### Configuración avanzada de Auth (Opcional)

      Soporta hooks personalizados de token de acceso, hooks de verificación MFA, hooks de verificación de contraseña, hooks personalizados de SMS/Email. Agrega las variables de entorno `GOTRUE_HOOK_*` correspondientes al servicio `auth`.

      **Asistente SQL de Studio:**
      Agrega `OPENAI_API_KEY` al servicio `studio`.

  id-ID:
    description: Alternatif open source untuk Firebase. Kami membangun fitur-fitur Firebase menggunakan alat open source tingkat enterprise.
    variables:
      - key: DASHBOARD_USERNAME
        type: STRING
        name: Nama Pengguna Dashboard
        description: Nama pengguna apa yang Anda inginkan untuk Dashboard Supabase Anda?
      - key: PUBLIC_DOMAIN
        type: DOMAIN
        name: Domain
        description: Domain apa yang Anda inginkan untuk Supabase Anda?
    readme: |
      # Supabase Self-hosted untuk Zeabur

      Ini adalah demo Supabase self-hosted untuk Zeabur.
      Anda dapat menggunakan template ini untuk mendeploy instance Supabase di Zeabur.

      ## Layanan

      Instansi Supabase ini mencakup **Kong** (API Gateway), **Studio** (Supabase Studio), **PostgreSQL** (Database), **Meta** (Postgres Meta), **REST** (PostgREST), **Auth** (GoTrue), **Supavisor** (Connection Pooler), **Realtime** (Langganan Perubahan Database), **Storage** (API Penyimpanan), **MinIO** (Penyimpanan Objek), **ImgProxy** (Pemrosesan Gambar), **Functions** (Edge Functions), **Vector** (Agregasi Log), dan **Analytics** (Logflare).

      Untuk informasi arsitektur yang detail, kunjungi [dokumentasi arsitektur resmi Supabase](https://supabase.com/docs/guides/self-hosting/docker#architecture).

      Jika Anda memerlukan layanan Supabase tambahan, silakan implementasikan sesuai dengan [file `docker-compose.yaml` upstream](https://github.com/supabase/supabase/blob/master/docker/docker-compose.yml) dan kirimkan perubahan Anda ke [server Discord kami](https://zeabur.com/dc). Ini berlaku untuk [Program Hadiah Kontribusi](https://zeabur.com/docs/id-ID/billing/reward) kami.

      ## Memulai

      ### Mengakses Dashboard

      Setelah deployment, dashboard Supabase Studio Anda akan tersedia di domain yang telah dikonfigurasi.

      **Menemukan Kredensial Anda:**
      1. Buka **layanan Kong** di proyek Zeabur Anda
      2. Klik tab **Instructions (Instruksi)**
      3. Anda akan menemukan:
         - **Supabase Username**: Nama pengguna dashboard Anda (dari variabel `DASHBOARD_USERNAME`)
         - **Supabase Password**: Password aman yang dihasilkan otomatis

      ### Kunci Keamanan Penting

      Kunci-kunci berikut tersedia di variabel lingkungan **layanan Kong**:

      | Kunci | Lokasi | Deskripsi |
      |-----|----------|-------------|
      | `JWT_SECRET` | Layanan Kong | Secret untuk menandatangani token JWT |
      | `ANON_KEY` | Layanan Kong | Kunci API publik untuk akses anonim |
      | `SERVICE_ROLE_KEY` | Layanan Kong | Kunci API admin dengan akses penuh |

      **⚠️ PENTING**: Kunci default hanya untuk tujuan demo. Anda **HARUS** menghasilkan kunci baru sebelum penggunaan produksi.

      **Cara Menghasilkan Kunci yang Aman:**
      1. Kunjungi [Generator JWT Supabase](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)
      2. Hasilkan kunci baru menggunakan `JWT_SECRET` kustom Anda:
         - Hasilkan kunci `anon` → gunakan sebagai `ANON_KEY`
         - Hasilkan kunci `service_role` (ditampilkan sebagai `SERVICE_KEY` di situs web) → gunakan sebagai `SERVICE_ROLE_KEY`
      3. Perbarui variabel lingkungan di layanan Kong
      4. Restart semua layanan untuk menerapkan perubahan:
         - Buka **Proyek** Anda → **Pengaturan** → **Umum**
         - Gulir ke bawah ke **Tindakan Batch**
         - Klik **Restart Semua** untuk me-restart semua layanan

      ## Mengamankan Layanan Anda

      Meskipun kami menyediakan beberapa secret contoh untuk memulai, Anda TIDAK BOLEH mendeploy setup Supabase Anda menggunakan default yang kami sediakan. Ikuti semua langkah di bagian ini untuk memastikan Anda memiliki setup yang aman, lalu restart semua layanan untuk menerapkan perubahan.

      [Panduan Resmi](https://supabase.com/docs/guides/self-hosting/docker#generate-api-keys)

      ## Konfigurasi

      ### Menambahkan dukungan Google OAuth

      Tambahkan variabel lingkungan ke layanan `auth`: `GOTRUE_EXTERNAL_GOOGLE_ENABLED=true`, `GOTRUE_EXTERNAL_GOOGLE_CLIENT_ID`, `GOTRUE_EXTERNAL_GOOGLE_SECRET`, `GOTRUE_EXTERNAL_GOOGLE_REDIRECT_URI`.

      ### Menambahkan dukungan Apple OAuth

      Tambahkan variabel lingkungan ke layanan `auth`: `GOTRUE_EXTERNAL_APPLE_ENABLED=true`, `GOTRUE_EXTERNAL_APPLE_CLIENT_ID`, `GOTRUE_EXTERNAL_APPLE_SECRET`, `GOTRUE_EXTERNAL_APPLE_REDIRECT_URI`.

      ### Mengonfigurasi layanan email SMTP (Integrasi Resend)

      Untuk mengaktifkan fungsi email, konfigurasikan SMTP menggunakan Resend. Tambahkan ke layanan `auth`: `GOTRUE_SMTP_HOST=smtp.resend.com`, `GOTRUE_SMTP_PORT=587`, `GOTRUE_SMTP_PASS` (kunci API Resend Anda), `GOTRUE_SMTP_ADMIN_EMAIL`, `GOTRUE_SMTP_SENDER_NAME`, `GOTRUE_SITE_URL`.

      ### Konfigurasi Auth lanjutan (Opsional)

      Mendukung hook token akses kustom, hook verifikasi MFA, hook verifikasi password, hook SMS/Email kustom. Tambahkan variabel lingkungan `GOTRUE_HOOK_*` yang sesuai ke layanan `auth`.

      **Asisten SQL Studio:**
      Tambahkan `OPENAI_API_KEY` ke layanan `studio`.